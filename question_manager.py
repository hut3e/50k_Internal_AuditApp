import streamlit as st
from database_helper import save_question, get_all_questions, get_question_by_id, update_question, delete_question
import json

def manage_questions():
    st.title("Qu·∫£n l√Ω c√¢u h·ªèi ISO 50001:2018")
    
    # Khi b·∫•m Tab n√†y, t·∫£i c√¢u h·ªèi t·ª´ database
    if "db_questions" not in st.session_state:
        st.session_state.db_questions = get_all_questions()
    
    # Kh·ªüi t·∫°o bi·∫øn c√¢u h·ªèi m·ªõi trong session state
    if "new_question" not in st.session_state:
        st.session_state.new_question = {
            "question": "",
            "type": "Checkbox",
            "answers": [],
            "correct": [],
            "score": 1
        }
    
    # Kh·ªüi t·∫°o bi·∫øn ch·ªânh s·ª≠a
    if "editing_question" not in st.session_state:
        st.session_state.editing_question = None
    
    # Kh·ªüi t·∫°o bi·∫øn x√°c nh·∫≠n x√≥a
    if "question_to_delete" not in st.session_state:
        st.session_state.question_to_delete = None

    # Ba tab: Th√™m c√¢u h·ªèi m·ªõi, Danh s√°ch c√¢u h·ªèi, v√† Ch·ªânh s·ª≠a c√¢u h·ªèi
    tabs = ["Th√™m c√¢u h·ªèi m·ªõi", "Danh s√°ch c√¢u h·ªèi"]
    
    # N·∫øu ƒëang ch·ªânh s·ª≠a c√¢u h·ªèi, th√™m tab ch·ªânh s·ª≠a
    if st.session_state.editing_question:
        tabs.append(f"Ch·ªânh s·ª≠a c√¢u h·ªèi #{st.session_state.editing_question['id']}")
    
    # T·∫°o tabs
    selected_tab = st.tabs(tabs)
    
    # Tab th√™m c√¢u h·ªèi m·ªõi
    with selected_tab[0]:
        add_new_question()
    
    # Tab danh s√°ch c√¢u h·ªèi
    with selected_tab[1]:
        list_questions()
    
    # Tab ch·ªânh s·ª≠a c√¢u h·ªèi (n·∫øu c√≥)
    if st.session_state.editing_question and len(selected_tab) > 2:
        with selected_tab[2]:
            edit_question()

def add_new_question():
    q = st.session_state.new_question
    q["question"] = st.text_area("N·ªôi dung c√¢u h·ªèi", value=q["question"], key="new_question_content", height=100)
    q["type"] = st.selectbox("Lo·∫°i c√¢u h·ªèi", ["Checkbox", "Combobox", "Essay"], 
                          index=["Checkbox", "Combobox", "Essay"].index(q["type"]),
                          key="new_question_type")
    q["score"] = st.number_input("S·ªë ƒëi·ªÉm", min_value=1, value=q["score"], key="new_question_score")

    # Qu·∫£n l√Ω danh s√°ch ƒë√°p √°n (ch·ªâ hi·ªÉn th·ªã cho Checkbox v√† Combobox)
    if q["type"] in ["Checkbox", "Combobox"]:
        st.subheader("Danh s√°ch ƒë√°p √°n")
        new_ans = st.text_input("Th√™m ƒë√°p √°n m·ªõi", key="new_answer_input")
        if st.button("‚ûï Th√™m ƒë√°p √°n", key="add_answer_btn"):
            if new_ans:
                q["answers"].append(new_ans)
                
        # Hi·ªÉn th·ªã c√°c ƒë√°p √°n hi·ªán c√≥
        for idx, ans in enumerate(q["answers"]):
            col1, col2 = st.columns([5, 1])
            col1.write(f"{idx + 1}. {ans}")
            if col2.button("üóëÔ∏è", key=f"del_ans_new_{idx}"):
                q["answers"].pop(idx)
                st.rerun()

        # ƒê√°p √°n ƒë√∫ng
        correct_ans = st.text_input("ƒê√°p √°n ƒë√∫ng (STT, ph√¢n c√°ch b·∫±ng d·∫•u ph·∫©y)", 
                                 value=",".join(map(str, q["correct"])),
                                 key="new_correct_answers")
        if correct_ans:
            try:
                q["correct"] = list(map(int, correct_ans.split(",")))
            except:
                st.warning("ƒê√°p √°n ph·∫£i l√† s·ªë, ph√¢n c√°ch b·∫±ng d·∫•u ph·∫©y")
    else:
        # ƒê·ªëi v·ªõi c√¢u h·ªèi Essay, kh√¥ng c·∫ßn danh s√°ch ƒë√°p √°n v√† ƒë√°p √°n ƒë√∫ng
        st.info("C√¢u h·ªèi t·ª± lu·∫≠n kh√¥ng y√™u c·∫ßu ƒë√°p √°n.")
        # ƒê·∫∑t gi√° tr·ªã m·∫∑c ƒë·ªãnh cho c√°c tr∆∞·ªùng c·∫ßn thi·∫øt
        q["answers"] = []
        q["correct"] = []
        
        # Th√™m tr∆∞·ªùng m·∫´u c√¢u tr·∫£ l·ªùi t·ª± lu·∫≠n (n·∫øu gi·∫£ng vi√™n mu·ªën cung c·∫•p g·ª£i √Ω)
        q["answer_template"] = st.text_area("M·∫´u c√¢u tr·∫£ l·ªùi (kh√¥ng b·∫Øt bu·ªôc)", 
                                          value=q.get("answer_template", ""),
                                          key="new_answer_template", 
                                          height=150)

    # L∆∞u c√¢u h·ªèi v√†o database
    if st.button("üß† L∆∞u c√¢u h·ªèi", key="save_question_btn"):
        if not q["question"]:
            st.error("Vui l√≤ng nh·∫≠p n·ªôi dung c√¢u h·ªèi")
        elif q["type"] in ["Checkbox", "Combobox"] and not q["answers"]:
            st.error("Vui l√≤ng th√™m √≠t nh·∫•t m·ªôt ƒë√°p √°n")
        elif q["type"] in ["Checkbox", "Combobox"] and not q["correct"]:
            st.error("Vui l√≤ng ch·ªâ ƒë·ªãnh √≠t nh·∫•t m·ªôt ƒë√°p √°n ƒë√∫ng")
        else:
            # L∆∞u v√†o database
            if save_question(q):
                # L√†m m·ªõi danh s√°ch c√¢u h·ªèi
                st.session_state.db_questions = get_all_questions()
                # L√†m m·ªõi form
                st.session_state.new_question = {
                    "question": "",
                    "type": "Checkbox",
                    "answers": [],
                    "correct": [],
                    "score": 1,
                    "answer_template": ""
                }
                st.success("‚úÖ ƒê√£ l∆∞u c√¢u h·ªèi v√†o h·ªá th·ªëng!")
                st.rerun()

def list_questions():
    # Hi·ªÉn th·ªã danh s√°ch c√¢u h·ªèi t·ª´ database
    questions = st.session_state.db_questions
    
    if not questions:
        st.info("Ch∆∞a c√≥ c√¢u h·ªèi n√†o trong h·ªá th·ªëng")
    else:
        st.subheader(f"ƒê√£ c√≥ {len(questions)} c√¢u h·ªèi")
        
        # H·ªôp x√°c nh·∫≠n x√≥a (n·∫øu c√≥)
        if st.session_state.question_to_delete:
            delete_confirmation()
        
        # T√≠nh t·ªïng ƒëi·ªÉm to√†n b·ªô c√¢u h·ªèi
        total_score = sum(q.get("score", 0) for q in questions)
        st.write(f"**T·ªïng ƒëi·ªÉm:** {total_score}")
        
        # B·ªô l·ªçc lo·∫°i c√¢u h·ªèi
        question_types = ["T·∫•t c·∫£", "Checkbox", "Combobox", "Essay"]
        selected_type = st.selectbox("L·ªçc theo lo·∫°i c√¢u h·ªèi:", question_types, key="filter_question_type")
        
        # ƒê·∫øm s·ªë c√¢u h·ªèi theo lo·∫°i
        checkbox_count = sum(1 for q in questions if q.get("type") == "Checkbox")
        combobox_count = sum(1 for q in questions if q.get("type") == "Combobox")
        essay_count = sum(1 for q in questions if q.get("type") == "Essay")
        
        # Hi·ªÉn th·ªã th·ªëng k√™
        col1, col2, col3, col4 = st.columns(4)
        col1.metric("T·ªïng s·ªë c√¢u h·ªèi", len(questions))
        col2.metric("C√¢u h·ªèi Checkbox", checkbox_count)
        col3.metric("C√¢u h·ªèi Combobox", combobox_count)
        col4.metric("C√¢u h·ªèi t·ª± lu·∫≠n", essay_count)
        
        # L·ªçc c√¢u h·ªèi theo lo·∫°i
        filtered_questions = questions
        if selected_type != "T·∫•t c·∫£":
            filtered_questions = [q for q in questions if q.get("type") == selected_type]
        
        for i, q in enumerate(filtered_questions):
            with st.expander(f"C√¢u {i + 1}: {q['question']}"):
                st.write(f"**ID:** {q['id']}")
                st.write(f"**Lo·∫°i c√¢u h·ªèi:** {q['type']}")
                st.write(f"**ƒêi·ªÉm:** {q['score']}")
                
                # Hi·ªÉn th·ªã theo lo·∫°i c√¢u h·ªèi
                if q['type'] in ["Checkbox", "Combobox"]:
                    st.write("**C√°c ƒë√°p √°n:**")
                    # ƒê·∫£m b·∫£o answers l√† list
                    answers = q["answers"]
                    if isinstance(answers, str):
                        try:
                            answers = json.loads(answers)
                        except:
                            answers = [answers]
                    
                    # ƒê·∫£m b·∫£o correct l√† list
                    correct = q["correct"]
                    if isinstance(correct, str):
                        try:
                            correct = json.loads(correct)
                        except:
                            try:
                                correct = [int(x.strip()) for x in correct.split(",")]
                            except:
                                correct = []
                    
                    for j, ans in enumerate(answers):
                        is_correct = (j + 1) in correct
                        st.write(f"- {j + 1}. {ans} {' ‚úÖ' if is_correct else ''}")
                else:
                    # Hi·ªÉn th·ªã th√¥ng tin c√¢u h·ªèi t·ª± lu·∫≠n
                    st.write("**Lo·∫°i c√¢u h·ªèi:** T·ª± lu·∫≠n")
                    if q.get("answer_template"):
                        st.write("**M·∫´u c√¢u tr·∫£ l·ªùi:**")
                        st.text_area("", value=q.get("answer_template", ""), disabled=True, key=f"view_template_{q['id']}", height=150)
                    else:
                        st.write("**M·∫´u c√¢u tr·∫£ l·ªùi:** Kh√¥ng c√≥")
                
                # Th√™m n√∫t s·ª≠a v√† x√≥a
                col1, col2 = st.columns(2)
                
                if col1.button("‚úèÔ∏è S·ª≠a", key=f"edit_q_{q['id']}"):
                    # L·∫•y d·ªØ li·ªáu c√¢u h·ªèi t·ª´ database
                    question_data = get_question_by_id(q['id'])
                    if question_data:
                        st.session_state.editing_question = question_data
                        st.rerun()
                
                if col2.button("üóëÔ∏è X√≥a", key=f"del_q_{q['id']}"):
                    st.session_state.question_to_delete = q
                    st.rerun()
                    
        if st.button("üîÑ L√†m m·ªõi danh s√°ch", key="refresh_question_list"):
            st.session_state.db_questions = get_all_questions()
            st.rerun()

def edit_question():
    """Ch·ª©c nƒÉng ch·ªânh s·ª≠a c√¢u h·ªèi"""
    q = st.session_state.editing_question
    q_id = q['id']  # L·∫•y ID c√¢u h·ªèi ƒë·ªÉ t·∫°o key duy nh·∫•t
    
    st.subheader(f"Ch·ªânh s·ª≠a c√¢u h·ªèi #{q_id}")
    
    # Form ch·ªânh s·ª≠a c√¢u h·ªèi
    edited_question = st.text_area("N·ªôi dung c√¢u h·ªèi", value=q["question"], key=f"edit_question_content_{q_id}", height=100)
    edited_type = st.selectbox("Lo·∫°i c√¢u h·ªèi", ["Checkbox", "Combobox", "Essay"], 
                             index=["Checkbox", "Combobox", "Essay"].index(q["type"]),
                             key=f"edit_question_type_{q_id}")
    edited_score = st.number_input("S·ªë ƒëi·ªÉm", min_value=1, value=q["score"], key=f"edit_question_score_{q_id}")
    
    # Sao ch√©p danh s√°ch ƒë√°p √°n ƒë·ªÉ c√≥ th·ªÉ ch·ªânh s·ª≠a
    if "edited_answers" not in st.session_state:
        # ƒê·∫£m b·∫£o q["answers"] l√† danh s√°ch
        if isinstance(q["answers"], str):
            try:
                # N·∫øu l√† JSON string, th·ª≠ chuy·ªÉn ƒë·ªïi th√†nh list
                answers_list = json.loads(q["answers"])
                st.session_state.edited_answers = answers_list
            except:
                # N·∫øu kh√¥ng th·ªÉ parse JSON, t·∫°o list t·ª´ string
                st.session_state.edited_answers = [q["answers"]]
        else:
            # N·∫øu ƒë√£ l√† list, sao ch√©p n√≥
            st.session_state.edited_answers = list(q["answers"])
    
    # Sao ch√©p ƒë√°p √°n ƒë√∫ng
    if "edited_correct" not in st.session_state:
        # ƒê·∫£m b·∫£o q["correct"] l√† danh s√°ch
        if isinstance(q["correct"], str):
            try:
                # N·∫øu l√† JSON string, th·ª≠ chuy·ªÉn ƒë·ªïi th√†nh list
                correct_list = json.loads(q["correct"])
                st.session_state.edited_correct = correct_list
            except:
                # N·∫øu kh√¥ng th·ªÉ parse JSON, th·ª≠ chuy·ªÉn ƒë·ªïi t·ª´ d·∫°ng "1,2,3" th√†nh [1,2,3]
                try:
                    st.session_state.edited_correct = [int(x.strip()) for x in q["correct"].split(",")]
                except:
                    st.session_state.edited_correct = []
        else:
            # N·∫øu ƒë√£ l√† list, sao ch√©p n√≥
            st.session_state.edited_correct = list(q["correct"])
    
    # Ch·ªâ hi·ªÉn th·ªã qu·∫£n l√Ω ƒë√°p √°n cho c√¢u h·ªèi Checkbox v√† Combobox
    if edited_type in ["Checkbox", "Combobox"]:
        # Qu·∫£n l√Ω danh s√°ch ƒë√°p √°n
        st.subheader("Danh s√°ch ƒë√°p √°n")
        new_ans = st.text_input("Th√™m ƒë√°p √°n m·ªõi", key=f"edit_new_ans_{q_id}")
        if st.button("‚ûï Th√™m ƒë√°p √°n", key=f"edit_add_ans_{q_id}"):
            if new_ans:
                st.session_state.edited_answers.append(new_ans)
                st.rerun()
        
        # Hi·ªÉn th·ªã c√°c ƒë√°p √°n hi·ªán c√≥
        for idx, ans in enumerate(st.session_state.edited_answers):
            col1, col2, col3 = st.columns([4, 1, 1])
            
            # Tr∆∞·ªùng nh·∫≠p li·ªáu ƒë·ªÉ s·ª≠a ƒë√°p √°n
            edited_ans = col1.text_input(f"ƒê√°p √°n {idx+1}", value=ans, key=f"edit_ans_{q_id}_{idx}")
            st.session_state.edited_answers[idx] = edited_ans
            
            # Checkbox ƒë·ªÉ ƒë√°nh d·∫•u ƒë√°p √°n ƒë√∫ng
            is_correct = (idx + 1) in st.session_state.edited_correct
            if col2.checkbox("‚úì", value=is_correct, key=f"edit_correct_{q_id}_{idx}"):
                if (idx + 1) not in st.session_state.edited_correct:
                    st.session_state.edited_correct.append(idx + 1)
            else:
                if (idx + 1) in st.session_state.edited_correct:
                    st.session_state.edited_correct.remove(idx + 1)
            
            # N√∫t x√≥a ƒë√°p √°n
            if col3.button("üóëÔ∏è", key=f"edit_del_ans_{q_id}_{idx}"):
                st.session_state.edited_answers.pop(idx)
                # C·∫≠p nh·∫≠t l·∫°i danh s√°ch ƒë√°p √°n ƒë√∫ng
                st.session_state.edited_correct = [c for c in st.session_state.edited_correct if c != idx + 1]
                # ƒêi·ªÅu ch·ªânh l·∫°i c√°c ƒë√°p √°n ƒë√∫ng c√≥ s·ªë th·ª© t·ª± l·ªõn h∆°n
                st.session_state.edited_correct = [c - 1 if c > idx + 1 else c for c in st.session_state.edited_correct]
                st.rerun()
        
        # Hi·ªÉn th·ªã m√¥ t·∫£ v·ªÅ ƒë√°p √°n ƒë√∫ng 
        st.info(f"""
        **H∆∞·ªõng d·∫´n ch·ªçn ƒë√°p √°n ƒë√∫ng:**
        - ƒê·ªëi v·ªõi c√¢u h·ªèi Checkbox: C√≥ th·ªÉ ch·ªçn nhi·ªÅu ƒë√°p √°n ƒë√∫ng.
        - ƒê·ªëi v·ªõi c√¢u h·ªèi Combobox: Ch·ªâ n√™n ch·ªçn m·ªôt ƒë√°p √°n ƒë√∫ng.
        - ƒê√°nh d·∫•u ‚úì cho c√°c ƒë√°p √°n ƒë√∫ng.
        """)
    else:
        # ƒê·ªëi v·ªõi c√¢u h·ªèi Essay, hi·ªÉn th·ªã c·∫•u h√¨nh kh√°c
        st.info("C√¢u h·ªèi t·ª± lu·∫≠n kh√¥ng y√™u c·∫ßu danh s√°ch ƒë√°p √°n.")
        
        # N·∫øu ch∆∞a c√≥ trong session_state, kh·ªüi t·∫°o t·ª´ d·ªØ li·ªáu c√¢u h·ªèi
        if "edited_answer_template" not in st.session_state:
            st.session_state.edited_answer_template = q.get("answer_template", "")
        
        # Th√™m tr∆∞·ªùng m·∫´u c√¢u tr·∫£ l·ªùi
        st.session_state.edited_answer_template = st.text_area(
            "M·∫´u c√¢u tr·∫£ l·ªùi (kh√¥ng b·∫Øt bu·ªôc)", 
            value=st.session_state.edited_answer_template,
            key=f"edit_answer_template_{q_id}",
            height=150
        )
        
        # ƒê·∫∑t gi√° tr·ªã m·∫∑c ƒë·ªãnh cho c√°c tr∆∞·ªùng c·∫ßn thi·∫øt
        st.session_state.edited_answers = []
        st.session_state.edited_correct = []
    
    # N√∫t l∆∞u v√† h·ªßy
    col1, col2 = st.columns(2)
    
    if col1.button("üíæ L∆∞u thay ƒë·ªïi", use_container_width=True, key=f"save_edit_{q_id}"):
        if not edited_question:
            st.error("Vui l√≤ng nh·∫≠p n·ªôi dung c√¢u h·ªèi")
        elif edited_type in ["Checkbox", "Combobox"] and not st.session_state.edited_answers:
            st.error("Vui l√≤ng th√™m √≠t nh·∫•t m·ªôt ƒë√°p √°n")
        elif edited_type in ["Checkbox", "Combobox"] and not st.session_state.edited_correct:
            st.error("Vui l√≤ng ch·ªâ ƒë·ªãnh √≠t nh·∫•t m·ªôt ƒë√°p √°n ƒë√∫ng")
        elif edited_type == "Combobox" and len(st.session_state.edited_correct) > 1:
            st.warning("C√¢u h·ªèi Combobox n√™n ch·ªâ c√≥ 1 ƒë√°p √°n ƒë√∫ng. H√£y xem x√©t l·∫°i ho·∫∑c ƒë·ªïi th√†nh Checkbox.")
            if st.button("V·∫´n mu·ªën l∆∞u", key=f"force_save_edit_{q_id}"):
                save_edited_question(q_id, edited_question, edited_type, edited_score)
        else:
            save_edited_question(q_id, edited_question, edited_type, edited_score)
    
    if col2.button("‚ùå H·ªßy", use_container_width=True, key=f"cancel_edit_{q_id}"):
        # X√≥a d·ªØ li·ªáu ch·ªânh s·ª≠a
        st.session_state.editing_question = None
        if "edited_answers" in st.session_state:
            del st.session_state.edited_answers
        if "edited_correct" in st.session_state:
            del st.session_state.edited_correct
        if "edited_answer_template" in st.session_state:
            del st.session_state.edited_answer_template
        st.rerun()

def reset_new_question_form():
    """Reset form c√¢u h·ªèi m·ªõi sau khi l∆∞u th√†nh c√¥ng"""
    # L√†m m·ªõi danh s√°ch c√¢u h·ªèi
    st.session_state.db_questions = get_all_questions()
    # L√†m m·ªõi form
    st.session_state.new_question = {
        "question": "",
        "type": "Checkbox",
        "answers": [],
        "correct": [],
        "score": 1
    }
    st.success("‚úÖ ƒê√£ l∆∞u c√¢u h·ªèi v√†o h·ªá th·ªëng!")
    st.rerun()

def save_edited_question(q_id, edited_question, edited_type, edited_score):
    """H√†m h·ªó tr·ª£ l∆∞u c√¢u h·ªèi ƒë√£ ch·ªânh s·ª≠a"""
    # C·∫≠p nh·∫≠t d·ªØ li·ªáu c√¢u h·ªèi
    updated_data = {
        "question": edited_question,
        "type": edited_type,
        "score": edited_score,
    }
    
    if edited_type in ["Checkbox", "Combobox"]:
        updated_data["answers"] = st.session_state.edited_answers
        updated_data["correct"] = st.session_state.edited_correct
    else:
        # ƒê·ªëi v·ªõi c√¢u h·ªèi Essay
        updated_data["answers"] = []
        updated_data["correct"] = []
        updated_data["answer_template"] = st.session_state.edited_answer_template
    
    # L∆∞u thay ƒë·ªïi v√†o database
    if update_question(q_id, updated_data):
        # X√≥a d·ªØ li·ªáu ch·ªânh s·ª≠a
        st.session_state.editing_question = None
        if "edited_answers" in st.session_state:
            del st.session_state.edited_answers
        if "edited_correct" in st.session_state:
            del st.session_state.edited_correct
        if "edited_answer_template" in st.session_state:
            del st.session_state.edited_answer_template
        
        # L√†m m·ªõi danh s√°ch c√¢u h·ªèi
        st.session_state.db_questions = get_all_questions()
        st.success("‚úÖ ƒê√£ c·∫≠p nh·∫≠t c√¢u h·ªèi th√†nh c√¥ng!")
        st.rerun()
    else:
        st.error("‚ùå C√≥ l·ªói x·∫£y ra khi c·∫≠p nh·∫≠t c√¢u h·ªèi!")

def delete_confirmation():
    """Hi·ªÉn th·ªã h·ªôp x√°c nh·∫≠n x√≥a c√¢u h·ªèi"""
    q = st.session_state.question_to_delete
    q_id = q['id']
    
    st.warning(f"B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a c√¢u h·ªèi sau ƒë√¢y?")
    st.info(f"C√¢u h·ªèi #{q_id}: {q['question']}")
    
    col1, col2 = st.columns(2)
    
    if col1.button("‚úÖ X√°c nh·∫≠n x√≥a", use_container_width=True, key=f"confirm_delete_{q_id}"):
        if delete_question(q_id):
            # L√†m m·ªõi danh s√°ch c√¢u h·ªèi
            st.session_state.db_questions = get_all_questions()
            st.session_state.question_to_delete = None
            st.success("‚úÖ ƒê√£ x√≥a c√¢u h·ªèi th√†nh c√¥ng!")
            st.rerun()
        else:
            st.error("‚ùå C√≥ l·ªói x·∫£y ra khi x√≥a c√¢u h·ªèi!")
    
    if col2.button("‚ùå H·ªßy", use_container_width=True, key=f"cancel_delete_{q_id}"):
        st.session_state.question_to_delete = None
        st.rerun()
